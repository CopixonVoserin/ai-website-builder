const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

/**
 * Code Generator - Actually builds working applications
 */
class CodeGenerator {
    constructor(aiService, workspaceBuilder) {
        this.aiService = aiService;
        this.workspaceBuilder = workspaceBuilder;
    }

    /**
     * Generate complete application from description
     */
    async generateApplication(workspaceId, requirements) {
        console.log(`Generating application for workspace ${workspaceId}`);

        try {
            // 1. Get workspace info
            const workspace = await this.workspaceBuilder.getWorkspace(workspaceId);
            
            // 2. Analyze requirements
            const analysis = await this.analyzeRequirements(requirements);
            
            // 3. Generate code files
            const files = await this.aiService.generateCode({
                description: requirements.description,
                projectType: analysis.projectType,
                features: analysis.features,
                techStack: analysis.techStack
            });

            // 4. Write files to workspace
            await this.writeFilesToWorkspace(workspace.path, files);

            // 5. Install dependencies
            await this.installDependencies(workspace.path);

            // 6. Initialize git and commit
            await this.commitChanges(workspace.path, 'Initial application generated by AI');

            // 7. Start the application
            const processInfo = await this.startApplication(workspace.path);

            return {
                success: true,
                filesGenerated: files.length,
                features: analysis.features,
                processInfo,
                message: 'Application generated successfully!'
            };

        } catch (error) {
            console.error('Application generation failed:', error);
            throw error;
        }
    }

    /**
     * Analyze requirements to determine what to build
     */
    async analyzeRequirements(requirements) {
        const { description } = requirements;
        
        // Use AI to analyze
        const analysis = await this.aiService.analyze({
            prompt: `Analyze this project requirement and extract:
            1. Project type (web app, api, blog, etc)
            2. Required features
            3. Best tech stack
            
            Requirement: ${description}`
        });

        // Extract from description if AI fails
        const projectType = this.detectProjectType(description);
        const features = this.extractFeatures(description);
        const techStack = this.suggestTechStack(projectType, features);

        return {
            projectType,
            features,
            techStack,
            ...analysis
        };
    }

    /**
     * Detect project type from description
     */
    detectProjectType(description) {
        const lower = description.toLowerCase();
        
        if (lower.includes('blog') || lower.includes('article')) return 'blog';
        if (lower.includes('shop') || lower.includes('store') || lower.includes('ecommerce')) return 'ecommerce';
        if (lower.includes('chat') || lower.includes('message')) return 'chat';
        if (lower.includes('api') || lower.includes('backend')) return 'api';
        if (lower.includes('dashboard') || lower.includes('admin')) return 'dashboard';
        if (lower.includes('game')) return 'game';
        
        return 'webapp';
    }

    /**
     * Extract features from description
     */
    extractFeatures(description) {
        const features = [];
        const lower = description.toLowerCase();

        // Authentication
        if (lower.includes('user') || lower.includes('login') || lower.includes('account')) {
            features.push('authentication');
        }

        // Database
        if (lower.includes('save') || lower.includes('store') || lower.includes('database')) {
            features.push('database');
        }

        // API
        if (lower.includes('api') || lower.includes('endpoint')) {
            features.push('api');
        }

        // Real-time
        if (lower.includes('real-time') || lower.includes('live') || lower.includes('chat')) {
            features.push('websocket');
        }

        // File handling
        if (lower.includes('upload') || lower.includes('image') || lower.includes('file')) {
            features.push('file-upload');
        }

        // Search
        if (lower.includes('search') || lower.includes('find')) {
            features.push('search');
        }

        // Email
        if (lower.includes('email') || lower.includes('notification')) {
            features.push('email');
        }

        // Payment
        if (lower.includes('payment') || lower.includes('stripe') || lower.includes('buy')) {
            features.push('payment');
        }

        return features.length > 0 ? features : ['basic-ui', 'database'];
    }

    /**
     * Suggest tech stack based on project type
     */
    suggestTechStack(projectType, features) {
        const base = 'Node.js, Express';
        
        // Frontend
        let frontend = 'HTML, CSS, JavaScript';
        if (features.includes('websocket')) {
            frontend = 'React, Socket.io';
        } else if (projectType === 'dashboard') {
            frontend = 'React, Chart.js';
        } else if (projectType === 'ecommerce') {
            frontend = 'Next.js, Tailwind CSS';
        }

        // Database
        let database = 'SQLite';
        if (projectType === 'ecommerce' || features.includes('payment')) {
            database = 'PostgreSQL';
        }

        return `${base}, ${frontend}, ${database}`;
    }

    /**
     * Write generated files to workspace
     */
    async writeFilesToWorkspace(workspacePath, files) {
        console.log(`Writing ${files.length} files to workspace...`);

        for (const file of files) {
            const filePath = path.join(workspacePath, file.path);
            
            // Create directory if needed
            const dir = path.dirname(filePath);
            await fs.mkdir(dir, { recursive: true });
            
            // Write file
            await fs.writeFile(filePath, file.content, 'utf8');
            console.log(`✓ Created ${file.path}`);
        }
    }

    /**
     * Install dependencies
     */
    async installDependencies(workspacePath) {
        console.log('Installing dependencies...');

        try {
            // Check if package.json exists
            const packageJsonPath = path.join(workspacePath, 'package.json');
            await fs.access(packageJsonPath);

            // Run npm install
            const { stdout, stderr } = await execAsync('npm install', {
                cwd: workspacePath
            });

            if (stderr && !stderr.includes('warn')) {
                console.error('npm install warnings:', stderr);
            }

            console.log('✓ Dependencies installed');
            return true;

        } catch (error) {
            console.error('Failed to install dependencies:', error);
            // Continue anyway - user might install manually
            return false;
        }
    }

    /**
     * Commit changes to git
     */
    async commitChanges(workspacePath, message) {
        try {
            // Add all files
            await execAsync('git add -A', { cwd: workspacePath });
            
            // Commit
            await execAsync(`git commit -m "${message}"`, { cwd: workspacePath });
            
            console.log('✓ Changes committed to git');
        } catch (error) {
            console.error('Git commit failed:', error);
            // Not critical - continue
        }
    }

    /**
     * Start the application
     */
    async startApplication(workspacePath) {
        console.log('Starting application...');

        try {
            // Check for start script
            const packageJsonPath = path.join(workspacePath, 'package.json');
            const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));

            const startCommand = packageJson.scripts?.start || 'node server.js';

            // Start in background (in production, use PM2 or similar)
            exec(startCommand, {
                cwd: workspacePath,
                env: { ...process.env, PORT: this.getNextPort() }
            }, (error, stdout, stderr) => {
                if (error) {
                    console.error('App start error:', error);
                }
            });

            const port = this.getNextPort();
            console.log(`✓ Application starting on port ${port}`);

            return {
                port,
                url: `http://localhost:${port}`,
                status: 'starting'
            };

        } catch (error) {
            console.error('Failed to start application:', error);
            return {
                status: 'failed',
                error: error.message
            };
        }
    }

    /**
     * Get next available port
     */
    getNextPort() {
        // In production, use proper port allocation
        return 3000 + Math.floor(Math.random() * 1000);
    }

    /**
     * Add feature to existing application
     */
    async addFeature(workspaceId, feature) {
        console.log(`Adding feature "${feature}" to workspace ${workspaceId}`);

        try {
            const workspace = await this.workspaceBuilder.getWorkspace(workspaceId);

            // Generate feature-specific code
            const files = await this.generateFeatureCode(workspace.path, feature);

            // Write files
            await this.writeFilesToWorkspace(workspace.path, files);

            // Update dependencies if needed
            if (files.some(f => f.path === 'package.json')) {
                await this.installDependencies(workspace.path);
            }

            // Commit
            await this.commitChanges(workspace.path, `Added feature: ${feature}`);

            return {
                success: true,
                filesModified: files.length,
                message: `Feature "${feature}" added successfully!`
            };

        } catch (error) {
            console.error('Failed to add feature:', error);
            throw error;
        }
    }

    /**
     * Generate code for specific feature
     */
    async generateFeatureCode(workspacePath, feature) {
        // Read existing package.json to understand project
        let projectInfo = {};
        try {
            const packageJson = await fs.readFile(
                path.join(workspacePath, 'package.json'),
                'utf8'
            );
            projectInfo = JSON.parse(packageJson);
        } catch (error) {
            // No package.json - create basic structure
        }

        // Generate feature-specific code
        const prompt = `
Add "${feature}" feature to existing Node.js/Express application.
Current project: ${projectInfo.name || 'web app'}
Generate complete, working code for this feature.
Include any new routes, database changes, and frontend updates.
`;

        const generatedFiles = await this.aiService.generateCode({
            description: prompt,
            projectType: 'feature',
            features: [feature],
            techStack: 'Node.js, Express'
        });

        return generatedFiles;
    }

    /**
     * Deploy application
     */
    async deployApplication(workspaceId, target = 'vercel') {
        console.log(`Deploying workspace ${workspaceId} to ${target}`);

        const workspace = await this.workspaceBuilder.getWorkspace(workspaceId);

        // In production, integrate with real deployment services
        // For now, simulate deployment
        const deploymentUrl = `https://${workspace.id}.vercel.app`;

        return {
            success: true,
            url: deploymentUrl,
            target,
            message: 'Deployment initiated!'
        };
    }

    /**
     * Get application status
     */
    async getApplicationStatus(workspaceId) {
        try {
            const workspace = await this.workspaceBuilder.getWorkspace(workspaceId);
            
            // Check if app is running (simplified)
            const files = await fs.readdir(workspace.path);
            const hasPackageJson = files.includes('package.json');
            const hasServer = files.some(f => f.includes('server') || f === 'app.js');

            return {
                status: hasPackageJson && hasServer ? 'ready' : 'building',
                files: files.length,
                hasCode: hasPackageJson,
                canDeploy: hasPackageJson && hasServer
            };

        } catch (error) {
            return {
                status: 'error',
                error: error.message
            };
        }
    }
}

module.exports = CodeGenerator;